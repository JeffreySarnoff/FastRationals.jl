<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Finding the Range · FastRationals.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FastRationals.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../bpp/">The BPP formula for PI</a></li><li class="current"><a class="toctext" href>Finding the Range</a><ul class="internal"><li><a class="toctext" href="#the-rational-milieu-1">the rational milieu</a></li></ul></li><li><a class="toctext" href="../thestatelessway/">The Stateless Way</a></li><li><a class="toctext" href="../mayoverflow/">What cannot overflow?</a></li><li><a class="toctext" href="../rationalmagnitude/">Rational Magnitude In Action</a></li><li><a class="toctext" href="../metaphoricalflashlight/">A metaphor that illuminates</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Finding the Range</a></li></ul><a class="edit-page" href="https://github.com/JeffreySarnoff/FastRationals.jl/blob/master/docs/src/findingtherange.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Finding the Range</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="The-Rational-Range-1" href="#The-Rational-Range-1">The Rational Range</a></h1><hr/><h2><a class="nav-anchor" id="the-rational-milieu-1" href="#the-rational-milieu-1">the rational milieu</a></h2><p>A rational value has two integer-valued components, the numerator and the denominator. Usually, rational arithmetic is applied to two values at a time.  <code>muladd</code> is applied to three rational values.  Here are <code>*</code>, <code>+</code> and <code>muladd</code> for rationals.</p><pre><code class="language-none">(a/b * c/d) == (a * c) / (b * d)

(a/b + c/d) == ((a * d) + (b * c)) / (b * d)

(a/b * c/d) + s/t == ((a * c * t) + (b * d * s)) / (b * d * t)</code></pre><p>Without loss of generality, assume these are values of type Rational{Int32}.  We know each numerator and each denominator hold signed integer values stored in 32 bits.  One bit of an Int32 is used to keep the sign, so there are 31 bits available to hold a magnitude. &lt;sup&gt;<a href="#usefulfiction">𝓪</a>&lt;/sup&gt;   The maximum magnitude available is <code>typemax(T)</code>, here <code>typemax(Int32) == 2_147_483_647</code>. This value becomes more meaningful when seen in hexadecimal (0x7fffffff), and to understand that, look at the first part in binary (0x7f == 0b0111_1111).  <code>typemax(T)</code> is an initial zero bit followed entirely by one bits, whenever <code>T</code> is built-in signed integer type.</p><p>Why does it matter?  Multiplication of two of these component values will overflow unless there are enough leading zero bits available within those values.  The product of two <code>B</code> bit <code>Signed</code> system types cannot overflow when there are more than <code>B+1</code> leading zero bits between the two values being multiplied. This is a sufficient characterization, and I prefer to work with a modicum of slack. The actual implementation uses <code>B+2</code> to allow for results that obtain from adding two products, and keeping that slack. &lt;sup&gt;<a href="#assumption1">𝒃</a>&lt;/sup&gt;</p><hr/><p>&lt;sup&gt;&lt;a name=&quot;usefulfiction&quot;&gt;<a href="#annotation">𝓪</a>&lt;/a&gt;&lt;/sup&gt; Actual Int32 quantities are kept as two&#39;s complement values, not sign+magnitude.</p><p>&lt;sup&gt;&lt;a name=&quot;assumption1&quot;&gt;<a href="#assumption1">𝒃</a>&lt;/a&gt;&lt;/sup&gt; We have quietly assumed both are nonnegative values.</p><footer><hr/><a class="previous" href="../bpp/"><span class="direction">Previous</span><span class="title">The BPP formula for PI</span></a><a class="next" href="../thestatelessway/"><span class="direction">Next</span><span class="title">The Stateless Way</span></a></footer></article></body></html>
